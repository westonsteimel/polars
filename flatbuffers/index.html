<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `flatbuffers` crate."><meta name="keywords" content="rust, rustlang, rust-lang, flatbuffers"><title>flatbuffers - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../flatbuffers/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate flatbuffers</p><div class="block version"><p>Version 0.8.3</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all flatbuffers's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class="location"></p><div id="sidebar-vars" data-name="flatbuffers" data-ty="mod" data-relpath="../"></div></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">flatbuffers</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/flatbuffers/lib.rs.html#17-58" title="goto source code">[src]</a></span></h1><div class="docblock"><h1 id="flatbuffers" class="section-header"><a href="#flatbuffers">FlatBuffers</a></h1>
<p>A library for memory-efficient serialization of data.</p>
<p>This crate provides runtime support for the FlatBuffers format in the Rust programming language.
To use this crate, first generate code with the <code>flatc</code> compiler, as described here: <a href="https://google.github.io/flatbuffers/">https://google.github.io/flatbuffers/</a>
Then, include that code into your project.
Finally, add this crate to your <code>Cargo.toml</code>.</p>
<p>At this time, Rust support is experimental, and APIs may change between minor versions.</p>
<p>At this time, to generate Rust code, you will need the latest <code>master</code> version of <code>flatc</code>, available from here: <a href="https://github.com/google/flatbuffers">https://github.com/google/flatbuffers</a>
(On OSX, you can install FlatBuffers from <code>HEAD</code> with the Homebrew package manager.)</p>
</div><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use <a class="mod" href="../bitflags/index.html" title="mod bitflags">bitflags</a>;</code></td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.BackwardsSOffset.html" title="flatbuffers::BackwardsSOffset struct">BackwardsSOffset</a></td><td class="docblock-short"><p>ForwardsSOffset is used by Follow to traverse a FlatBuffer: the pointer
is incremented by the <em>negative</em> of the value contained in this type.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.FileIdentifier.html" title="flatbuffers::FileIdentifier struct">FileIdentifier</a></td><td class="docblock-short"><p>FileIdentifier is used by Follow to traverse a FlatBuffer: the pointer is
dereferenced into a byte slice, whose bytes are the file identifer value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.FlatBufferBuilder.html" title="flatbuffers::FlatBufferBuilder struct">FlatBufferBuilder</a></td><td class="docblock-short"><p>FlatBufferBuilder builds a FlatBuffer through manipulating its internal
state. It has an owned <code>Vec&lt;u8&gt;</code> that grows as needed (up to the hardcoded
limit of 2GiB, which is set by the FlatBuffers format).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.FollowStart.html" title="flatbuffers::FollowStart struct">FollowStart</a></td><td class="docblock-short"><p>FollowStart wraps a Follow impl in a struct type. This can make certain
programming patterns more ergonomic.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ForwardsUOffset.html" title="flatbuffers::ForwardsUOffset struct">ForwardsUOffset</a></td><td class="docblock-short"><p>ForwardsUOffset is used by Follow to traverse a FlatBuffer: the pointer
is incremented by the value contained in this type.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.ForwardsVOffset.html" title="flatbuffers::ForwardsVOffset struct">ForwardsVOffset</a></td><td class="docblock-short"><p>ForwardsVOffset is used by Follow to traverse a FlatBuffer: the pointer
is incremented by the value contained in this type.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SkipFileIdentifier.html" title="flatbuffers::SkipFileIdentifier struct">SkipFileIdentifier</a></td><td class="docblock-short"><p>SkipFileIdentifier is used by Follow to traverse a FlatBuffer: the pointer
is incremented by a fixed constant in order to skip over the file
identifier value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SkipRootOffset.html" title="flatbuffers::SkipRootOffset struct">SkipRootOffset</a></td><td class="docblock-short"><p>SkipRootOffset is used by Follow to traverse a FlatBuffer: the pointer is
incremented by a fixed constant in order to skip over the root offset value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SkipSizePrefix.html" title="flatbuffers::SkipSizePrefix struct">SkipSizePrefix</a></td><td class="docblock-short"><p>SkipSizePrefix is used by Follow to traverse a FlatBuffer: the pointer is
incremented by a fixed constant in order to skip over the size prefix value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Table.html" title="flatbuffers::Table struct">Table</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.TableFinishedWIPOffset.html" title="flatbuffers::TableFinishedWIPOffset struct">TableFinishedWIPOffset</a></td><td class="docblock-short"><p>TableFinishedWIPOffset marks a WIPOffset as being for a finished table.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.TableUnfinishedWIPOffset.html" title="flatbuffers::TableUnfinishedWIPOffset struct">TableUnfinishedWIPOffset</a></td><td class="docblock-short"><p>TableUnfinishedWIPOffset marks a WIPOffset as being for an unfinished table.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.UnionWIPOffset.html" title="flatbuffers::UnionWIPOffset struct">UnionWIPOffset</a></td><td class="docblock-short"><p>UnionWIPOffset marks a WIPOffset as being for a union value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.VTableWIPOffset.html" title="flatbuffers::VTableWIPOffset struct">VTableWIPOffset</a></td><td class="docblock-short"><p>VTableWIPOffset marks a WIPOffset as being for a vtable.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Vector.html" title="flatbuffers::Vector struct">Vector</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.VectorIter.html" title="flatbuffers::VectorIter struct">VectorIter</a></td><td class="docblock-short"><p>An iterator over a <code>Vector</code>.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Verifier.html" title="flatbuffers::Verifier struct">Verifier</a></td><td class="docblock-short"><p>Carries the verification state. Should not be reused between tables.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.VerifierOptions.html" title="flatbuffers::VerifierOptions struct">VerifierOptions</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.WIPOffset.html" title="flatbuffers::WIPOffset struct">WIPOffset</a></td><td class="docblock-short"><p>WIPOffset contains an UOffsetT with a special meaning: it is the location of
data relative to the <em>end</em> of an in-progress FlatBuffer. The
FlatBufferBuilder uses this to track the location of objects in an absolute
way. The impl of Push converts a WIPOffset into a ForwardsUOffset.</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.ErrorTraceDetail.html" title="flatbuffers::ErrorTraceDetail enum">ErrorTraceDetail</a></td><td class="docblock-short"><p>Traces the location of data errors. Not populated for Dos detecting errors.
Useful for MissingRequiredField and Utf8Error in particular, though
the other errors should not be producible by correct flatbuffers implementations.</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.InvalidFlatbuffer.html" title="flatbuffers::InvalidFlatbuffer enum">InvalidFlatbuffer</a></td><td class="docblock-short"><p>Describes how a flatuffer is invalid and, for data errors, roughly where. No extra tracing
information is given for DoS detecting errors since it will probably be a lot.</p>
</td></tr></table><h2 id="constants" class="section-header"><a href="#constants">Constants</a></h2>
<table><tr class="module-item"><td><a class="constant" href="constant.FILE_IDENTIFIER_LENGTH.html" title="flatbuffers::FILE_IDENTIFIER_LENGTH constant">FILE_IDENTIFIER_LENGTH</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.FLATBUFFERS_MAX_BUFFER_SIZE.html" title="flatbuffers::FLATBUFFERS_MAX_BUFFER_SIZE constant">FLATBUFFERS_MAX_BUFFER_SIZE</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_F32.html" title="flatbuffers::SIZE_F32 constant">SIZE_F32</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_F64.html" title="flatbuffers::SIZE_F64 constant">SIZE_F64</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_I8.html" title="flatbuffers::SIZE_I8 constant">SIZE_I8</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_I16.html" title="flatbuffers::SIZE_I16 constant">SIZE_I16</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_I32.html" title="flatbuffers::SIZE_I32 constant">SIZE_I32</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_I64.html" title="flatbuffers::SIZE_I64 constant">SIZE_I64</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_SIZEPREFIX.html" title="flatbuffers::SIZE_SIZEPREFIX constant">SIZE_SIZEPREFIX</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_SOFFSET.html" title="flatbuffers::SIZE_SOFFSET constant">SIZE_SOFFSET</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_U8.html" title="flatbuffers::SIZE_U8 constant">SIZE_U8</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_U16.html" title="flatbuffers::SIZE_U16 constant">SIZE_U16</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_U32.html" title="flatbuffers::SIZE_U32 constant">SIZE_U32</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_U64.html" title="flatbuffers::SIZE_U64 constant">SIZE_U64</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_UOFFSET.html" title="flatbuffers::SIZE_UOFFSET constant">SIZE_UOFFSET</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.SIZE_VOFFSET.html" title="flatbuffers::SIZE_VOFFSET constant">SIZE_VOFFSET</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.VTABLE_METADATA_FIELDS.html" title="flatbuffers::VTABLE_METADATA_FIELDS constant">VTABLE_METADATA_FIELDS</a></td><td class="docblock-short"></td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.EndianScalar.html" title="flatbuffers::EndianScalar trait">EndianScalar</a></td><td class="docblock-short"><p>Trait for values that must be stored in little-endian byte order, but
might be represented in memory as big-endian. Every type that implements
EndianScalar is a valid FlatBuffers scalar value.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Follow.html" title="flatbuffers::Follow trait">Follow</a></td><td class="docblock-short"><p>Follow is a trait that allows us to access FlatBuffers in a declarative,
type safe, and fast way. They compile down to almost no code (after
optimizations). Conceptually, Follow lifts the offset-based access
patterns of FlatBuffers data into the type system. This trait is used
pervasively at read time, to access tables, vtables, vectors, strings, and
all other data. At this time, Follow is not utilized much on the write
path.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Push.html" title="flatbuffers::Push trait">Push</a></td><td class="docblock-short"><p>Trait to abstract over functionality needed to write values (either owned
or referenced). Used in FlatBufferBuilder and implemented for generated
types.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.SafeSliceAccess.html" title="flatbuffers::SafeSliceAccess trait">SafeSliceAccess</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="trait" href="trait.SimpleToVerifyInSlice.html" title="flatbuffers::SimpleToVerifyInSlice trait">SimpleToVerifyInSlice</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="trait" href="trait.Verifiable.html" title="flatbuffers::Verifiable trait">Verifiable</a></td><td class="docblock-short"></td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.buffer_has_identifier.html" title="flatbuffers::buffer_has_identifier fn">buffer_has_identifier</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.byte_swap_f32.html" title="flatbuffers::byte_swap_f32 fn">byte_swap_f32</a></td><td class="docblock-short"><p>Swaps the bytes of an f32.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.byte_swap_f64.html" title="flatbuffers::byte_swap_f64 fn">byte_swap_f64</a></td><td class="docblock-short"><p>Swaps the bytes of an f64.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.emplace_scalar.html" title="flatbuffers::emplace_scalar fn">emplace_scalar</a></td><td class="docblock-short"><p>Place an EndianScalar into the provided mutable byte slice. Performs
endian conversion, if necessary.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.field_index_to_field_offset.html" title="flatbuffers::field_index_to_field_offset fn">field_index_to_field_offset</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.follow_cast_ref.html" title="flatbuffers::follow_cast_ref fn">follow_cast_ref</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.read_scalar.html" title="flatbuffers::read_scalar fn">read_scalar</a></td><td class="docblock-short"><p>Read an EndianScalar from the provided byte slice. Performs endian
conversion, if necessary.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.read_scalar_at.html" title="flatbuffers::read_scalar_at fn">read_scalar_at</a></td><td class="docblock-short"><p>Read an EndianScalar from the provided byte slice at the specified location.
Performs endian conversion, if necessary.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.root.html" title="flatbuffers::root fn">root</a></td><td class="docblock-short"><p>Gets the root of the Flatbuffer, verifying it first with default options.
Note that verification is an experimental feature and may not be maximally performant or
catch every error (though that is the goal). See the <code>_unchecked</code> variants for previous
behavior.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.root_unchecked.html" title="flatbuffers::root_unchecked fn">root_unchecked</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>Gets root for a trusted Flatbuffer.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.root_with_opts.html" title="flatbuffers::root_with_opts fn">root_with_opts</a></td><td class="docblock-short"><p>Gets the root of the Flatbuffer, verifying it first with given options.
Note that verification is an experimental feature and may not be maximally performant or
catch every error (though that is the goal). See the <code>_unchecked</code> variants for previous
behavior.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.size_prefixed_root.html" title="flatbuffers::size_prefixed_root fn">size_prefixed_root</a></td><td class="docblock-short"><p>Gets the root of a size prefixed Flatbuffer, verifying it first with default options.
Note that verification is an experimental feature and may not be maximally performant or
catch every error (though that is the goal). See the <code>_unchecked</code> variants for previous
behavior.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.size_prefixed_root_unchecked.html" title="flatbuffers::size_prefixed_root_unchecked fn">size_prefixed_root_unchecked</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>Gets root for a trusted, size prefixed, Flatbuffer.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.size_prefixed_root_with_opts.html" title="flatbuffers::size_prefixed_root_with_opts fn">size_prefixed_root_with_opts</a></td><td class="docblock-short"><p>Gets the root of a size prefixed Flatbuffer, verifying it first with given options.
Note that verification is an experimental feature and may not be maximally performant or
catch every error (though that is the goal). See the <code>_unchecked</code> variants for previous
behavior.</p>
</td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="module-item"><td><a class="type" href="type.SOffsetT.html" title="flatbuffers::SOffsetT type">SOffsetT</a></td><td class="docblock-short"><p>SOffsetT is a relative pointer from tables to their vtables.</p>
</td></tr><tr class="module-item"><td><a class="type" href="type.UOffsetT.html" title="flatbuffers::UOffsetT type">UOffsetT</a></td><td class="docblock-short"><p>UOffsetT is used represent both for relative pointers and lengths of vectors.</p>
</td></tr><tr class="module-item"><td><a class="type" href="type.VOffsetT.html" title="flatbuffers::VOffsetT type">VOffsetT</a></td><td class="docblock-short"><p>VOffsetT is a relative pointer in vtables to point from tables to field data.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="flatbuffers"></div>
    <script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>